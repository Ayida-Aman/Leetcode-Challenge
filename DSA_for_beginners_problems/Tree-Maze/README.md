# Tree Maze ğŸ§­ğŸŒ²

ğŸŸ¢ **Recursive Exploration Through Paths, Possibilities, and Patterns**

## ğŸ“Œ Overview

Today we entered the mysterious world of **Tree Mazes**, where recursion leads us through winding paths and layered decisions. Whether tracing a root-to-leaf path with a specific sum, generating all possible subsets, or navigating combinations toward a target, each problem demanded clarity in **choice**, **backtracking**, and **state tracking**.

This trio of challenges helped us master the core essence of **recursive decision-making** â€” making moves, undoing them, and evaluating every possible outcome in a branching universe.

## ğŸ† Key Learnings

- **Recursive Branching** â†’ DFS-style exploration builds path-by-path logic.
- **Backtracking Brilliance** â†’ Remove last steps, re-explore alternatives without residue.
- **Stateful Tracking** â†’ Maintain dynamic lists, indices, and totals through each call.
- **Substructure Insights** â†’ Problems often break into solvable chunks â€” subsets, sums, suffixes.

## ğŸ“‚ Problems Solved

### **Path Sum**

ğŸ”— [Problem Link](https://leetcode.com/problems/path-sum/)

- Explored all root-to-leaf paths to see if any matched a target sum.
- Applied DFS with **cumulative tracking** and **leaf detection**.
- Reinforced base case conditions and recursive depth logic.

### **Subsets**

ğŸ”— [Problem Link](https://leetcode.com/problems/subsets/)

- Generated all possible combinations (power set) from a given array.
- Used DFS and **backtracking** to explore inclusion/exclusion per element.
- Mastered control of recursion depth and set construction.

### **Combination Sum**

ğŸ”— [Problem Link](https://leetcode.com/problems/combination-sum/)

- Built all unique combinations that summed to a target value.
- Allowed **reuse of candidates**, with index tracking to avoid unnecessary repeats.
- Emphasized pruning invalid paths early to keep traversal efficient.

## ğŸ”— Course Link

ğŸ”— [Neetcodeâ€™s DSA for Beginners](https://neetcode.io/courses/dsa-for-beginners)

## ğŸ¯ Key Takeaways

- Recursive decision trees can solve a vast spectrum of problems â€” if we manage state well.
- Backtracking is like a breadcrumb trail â€” powerful when used cleanly and purposefully.
- Many complex problems can be viewed as structured tree mazes â€” let recursion be your compass.

---

âœ¨ If recursion were a forest, youâ€™d be the path Iâ€™d always choose â€” no backtracking needed ğŸ˜ŒğŸŒ¿ğŸ’–