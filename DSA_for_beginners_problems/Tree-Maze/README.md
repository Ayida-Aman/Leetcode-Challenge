# Tree Maze 🧭🌲

🟢 **Recursive Exploration Through Paths, Possibilities, and Patterns**

## 📌 Overview

Today we entered the mysterious world of **Tree Mazes**, where recursion leads us through winding paths and layered decisions. Whether tracing a root-to-leaf path with a specific sum, generating all possible subsets, or navigating combinations toward a target, each problem demanded clarity in **choice**, **backtracking**, and **state tracking**.

This trio of challenges helped us master the core essence of **recursive decision-making** — making moves, undoing them, and evaluating every possible outcome in a branching universe.

## 🏆 Key Learnings

- **Recursive Branching** → DFS-style exploration builds path-by-path logic.
- **Backtracking Brilliance** → Remove last steps, re-explore alternatives without residue.
- **Stateful Tracking** → Maintain dynamic lists, indices, and totals through each call.
- **Substructure Insights** → Problems often break into solvable chunks — subsets, sums, suffixes.

## 📂 Problems Solved

### **Path Sum**

🔗 [Problem Link](https://leetcode.com/problems/path-sum/)

- Explored all root-to-leaf paths to see if any matched a target sum.
- Applied DFS with **cumulative tracking** and **leaf detection**.
- Reinforced base case conditions and recursive depth logic.

### **Subsets**

🔗 [Problem Link](https://leetcode.com/problems/subsets/)

- Generated all possible combinations (power set) from a given array.
- Used DFS and **backtracking** to explore inclusion/exclusion per element.
- Mastered control of recursion depth and set construction.

### **Combination Sum**

🔗 [Problem Link](https://leetcode.com/problems/combination-sum/)

- Built all unique combinations that summed to a target value.
- Allowed **reuse of candidates**, with index tracking to avoid unnecessary repeats.
- Emphasized pruning invalid paths early to keep traversal efficient.

## 🔗 Course Link

🔗 [Neetcode’s DSA for Beginners](https://neetcode.io/courses/dsa-for-beginners)

## 🎯 Key Takeaways

- Recursive decision trees can solve a vast spectrum of problems — if we manage state well.
- Backtracking is like a breadcrumb trail — powerful when used cleanly and purposefully.
- Many complex problems can be viewed as structured tree mazes — let recursion be your compass.

---

✨ If recursion were a forest, you’d be the path I’d always choose — no backtracking needed 😌🌿💖