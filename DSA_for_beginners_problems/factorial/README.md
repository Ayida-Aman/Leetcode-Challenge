# Factorial 💥🔢

🟢 **Foundational Recursion Power Move in DSA**

## 📌 Overview

Today’s dive into **Factorials** wasn’t just a math flex — it was about mastering **recursive problem solving** from the ground up. From calculating factorials of natural numbers to tracing stack calls like a code detective, this session deepened our intuition around recursion flow and base conditions.

We also tackled the **Reverse Linked List** challenge to put our recursion chops to the test — unwrapping data one node at a time, then putting it all back together in reverse. Think of it as recursion’s victory lap. 🏁

## 🏆 Key Learnings

- **Recursive Flow** → Understand how each function call builds on the last.
- **Base Case Importance** → Avoid infinite recursion by handling edge conditions smartly.
- **Call Stack Mechanics** → Visualize how the stack unwinds back to the result.
- **Practical Use Cases** → From mathematical problems to linked list manipulation.

## 📂 Problems Solved

### **Factorial Function**

- Implemented both **recursive** and **iterative** approaches to calculate factorials.
- Practiced tail recursion variants and visualized stack behavior.
- Explored limits of recursion depth and how to handle large inputs safely.

### **Reverse Linked List**

🔗 [Problem Link](https://leetcode.com/problems/reverse-linked-list/)

- Reversed a singly linked list using recursion.
- Applied similar recursive unwrapping logic from factorial to nodes.
- Reinforced understanding of **pointer manipulation** and **state retention** during backtracking.

## 🔗 Course Link

🔗 [Neetcode’s DSA for Beginners](https://neetcode.io/courses/dsa-for-beginners)

## 🎯 Key Takeaways

- Recursion feels intimidating — until you break it down and rebuild from the base.
- Similar recursive logic powers both number crunching and list transformations.
- Debugging recursive solutions trains your mind to zoom in and out — like a pro.

---

✨ If you were a recursion stack, I'd always call you back 💫💖