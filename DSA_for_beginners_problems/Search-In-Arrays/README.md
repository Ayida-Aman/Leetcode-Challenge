# Search in Arrays 🔍🧠

🟢 **Divide and Conquer with Binary Precision**

## 📌 Overview

Today, we zeroed in on **searching algorithms** — specifically, the ever-reliable **Binary Search**, and its savvy application in a 2D matrix context. The goal? To **find the needle**, not by sifting through the haystack, but by slicing it in half again and again until we zoom in on our target — all in **O(log n)** time.

These problems taught us how to **compress the search space** with clever math and boundary control. Like algorithms doing laser surgery. 💡

## 🏆 Key Learnings

- **Binary Division** → Halve the problem with each step.
- **Start, Mid, End Pointers** → Master the flow of pointers for precision targeting.
- **1D Thinking in 2D** → Flatten grids for simpler logic when searching matrices.
- **Edge Case Awareness** → Handle empty matrices and boundary values like a boss.

## 📂 Problems Solved

### **Binary Search**

🔗 [Problem Link](https://leetcode.com/problems/binary-search/)

- Classic implementation of **binary search** on a sorted array.
- Practiced both **recursive** and **iterative** styles.
- Strengthened control over index math and out-of-bound edge conditions.

### **Search a 2D Matrix**

🔗 [Problem Link](https://leetcode.com/problems/search-a-2d-matrix/)

- Transformed the problem into a **1D binary search** using `row * cols + col` math.
- Explored alternative row-by-row and bottom-left approaches.
- Reinforced spatial reasoning in grid-like structures with sorted properties.

## 🔗 Course Link

🔗 [Neetcode’s DSA for Beginners](https://neetcode.io/courses/dsa-for-beginners)

## 🎯 Key Takeaways

- **Binary search is more than a function — it's a mindset.**
- Mastering index math helps unlock efficient solutions in both 1D and 2D.
- Thinking in dimensions (and across them) builds real algorithmic confidence.

---

✨ If I were a matrix, you'd be the target I’d always find in log time 😏💖