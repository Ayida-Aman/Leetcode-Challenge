# Merge Sort ⚔️✨

🟢 **Divide and Conquer Legend in DSA**

## 📌 Overview

Today, we tackled the mighty **Merge Sort**, a recursive sorting algorithm that embraces the **Divide and Conquer** paradigm. By continuously dividing an unsorted array into smaller halves and then merging those halves in order, Merge Sort achieves predictable performance and stability — even with large datasets.

To put this concept into action, we took on **two LeetCode challenges** that pushed this elegant technique to the limit!

## 🏆 Key Learnings

- **Recursive Thinking** → Break problems into sub-problems you can solve independently.
- **Merging Power** → Efficiently combine sorted arrays into one clean result.
- **Stable Sort** → Preserves the relative order of equal elements — crucial in many apps.
- **Predictable Performance** → Consistent O(n log n) runtime, even in worst-case scenarios.

## 📂 Problems Solved

### **Sort an Array**

🔗 [Problem Link](https://leetcode.com/problems/sort-an-array/)

- Implemented **Merge Sort** to sort a complete array of integers.
- Reinforced fundamental operations like **splitting**, **recursive sorting**, and **merging**.

### **Merge k Sorted Lists**

🔗 [Problem Link](https://leetcode.com/problems/merge-k-sorted-lists/)

- Applied **k-way merging** using recursive divide-and-conquer.
- Sharpened skills in merging multiple sorted linked lists into one fully sorted stream.
- Experimented with **priority queues** and **heap optimizations** for extra flair.

## 🔗 Course Link

🔗 [Neetcode’s DSA for Beginners](https://neetcode.io/courses/dsa-for-beginners)

## 🎯 Key Takeaways

- Empowers you to handle large, unsorted data with confidence.
- Highlights the beauty of **recursive problem-solving**.
- Strengthens your toolkit for tackling advanced sorting and merging challenges.

---

✨ If coding were a merge function, you'd be the one I'd always keep on the left — because you're already sorted 😌💖