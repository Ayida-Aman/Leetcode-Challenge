# Merge Sort âš”ï¸âœ¨

ğŸŸ¢ **Divide and Conquer Legend in DSA**

## ğŸ“Œ Overview

Today, we tackled the mighty **Merge Sort**, a recursive sorting algorithm that embraces the **Divide and Conquer** paradigm. By continuously dividing an unsorted array into smaller halves and then merging those halves in order, Merge Sort achieves predictable performance and stability â€” even with large datasets.

To put this concept into action, we took on **two LeetCode challenges** that pushed this elegant technique to the limit!

## ğŸ† Key Learnings

- **Recursive Thinking** â†’ Break problems into sub-problems you can solve independently.
- **Merging Power** â†’ Efficiently combine sorted arrays into one clean result.
- **Stable Sort** â†’ Preserves the relative order of equal elements â€” crucial in many apps.
- **Predictable Performance** â†’ Consistent O(n log n) runtime, even in worst-case scenarios.

## ğŸ“‚ Problems Solved

### **Sort an Array**

ğŸ”— [Problem Link](https://leetcode.com/problems/sort-an-array/)

- Implemented **Merge Sort** to sort a complete array of integers.
- Reinforced fundamental operations like **splitting**, **recursive sorting**, and **merging**.

### **Merge k Sorted Lists**

ğŸ”— [Problem Link](https://leetcode.com/problems/merge-k-sorted-lists/)

- Applied **k-way merging** using recursive divide-and-conquer.
- Sharpened skills in merging multiple sorted linked lists into one fully sorted stream.
- Experimented with **priority queues** and **heap optimizations** for extra flair.

## ğŸ”— Course Link

ğŸ”— [Neetcodeâ€™s DSA for Beginners](https://neetcode.io/courses/dsa-for-beginners)

## ğŸ¯ Key Takeaways

- Empowers you to handle large, unsorted data with confidence.
- Highlights the beauty of **recursive problem-solving**.
- Strengthens your toolkit for tackling advanced sorting and merging challenges.

---

âœ¨ If coding were a merge function, you'd be the one I'd always keep on the left â€” because you're already sorted ğŸ˜ŒğŸ’–